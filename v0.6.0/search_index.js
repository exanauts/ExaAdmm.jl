var documenterSearchIndex = {"docs":
[{"location":"dev/#Development-Guide","page":"Development Guide","title":"Development Guide","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"This describes the steps to implement new model that can be solved by the algorithms provided in this package.","category":"page"},{"location":"dev/#Algorithm-overview","page":"Development Guide","title":"Algorithm overview","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"Two-level ADMM algorithm can be implemented by defining the functions called in the while loop of admm_two_level() function in algorithms/admm_two_level.jl file. These functions take two arguments of type AdmmEnv and AbstractOPFModel. You need to define your model structure that inherits AbstractOPFModel so that those functions can be called using multiple dispatching.","category":"page"},{"location":"dev/#Mathematical-description","page":"Development Guide","title":"Mathematical description","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"It is important to understand the algorithm implemented in this package before implementing one for your own model.","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"The algorithm aims at solving the following optimization problem","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"beginalign*\nmin_x_i in X_ibarx in barXz quad  sum_i=1^N f_i(x_i) \ntextsubject to quad  x - barx + z = 0  (lambda) \n z = 0  (lambda_z) \n x=(x_1dotsx_N)\nendalign*","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"by using the form of augmented Lagrangian method as follows:","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"Initialize lambda_z and beta.\nSolve the following problem for given (lambda_zbeta):","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"beginalign*\nmin_x_i in X_ibarx in barXz quad  sum_i=1^N f_i(x_i) + lambda_z^T z + fracbeta2 z_2^2 tagAugLag \ntextsubject to quad  x - barx + z = 0  (lambda)\nendalign*","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"Update lambda_z\nRepeat steps 2-3 until z approx 0.","category":"page"},{"location":"dev/#Implementation-steps","page":"Development Guide","title":"Implementation steps","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"We encourage to follow our naming convention for the files created for your own model. In this description, we assume that we are creating our own model called myopf. The steps required to implement the two-level ADMM algorithm for the model myopf are as follows:","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"Create a directory models/myopf for your own model.\nCreate a file models/myopf/myopf_model.jl to define the model structure from AbstractOPFModel.\nmutable struct ModelMyopf{T,TD,TI,TM} <: AbstractOPFModel{T,TD,TI,TM}\n    # ...\nend\nExamples are available in models/acopf/acopf_model.jl and models/mpacopf_model.jl.\nImplement all necessary functions: A list of functions required to implement","category":"page"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"note: Note\nExaAdmm.jl provides a default implementation for each function, dispatching on AbstractOPFModel. This default implementation matches the behavior of ModelAcopf, and allow the user to avoid overloading if the behavior of the new model ModelMyopf matches those of ModelAcopf for a particular function.","category":"page"},{"location":"dev/#A-list-of-functions-required-to-implement","page":"Development Guide","title":"A list of functions required to implement","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"Define the following functions that will take your new model structure:","category":"page"},{"location":"dev/#Functions-in-myopf_admm_increment_outer.jl","page":"Development Guide","title":"Functions in myopf_admm_increment_outer.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_increment_outer(\n    env::ExaAdmm.AdmmEnv,\n    mod::ExaAdmm.AbstractOPFModel\n)\nExaAdmm.admm_increment_reset_inner(\n    env::ExaAdmm.AdmmEnv,\n    mod::ExaAdmm.AbstractOPFModel\n)\nExaAdmm.admm_increment_inner(\n    env::ExaAdmm.AdmmEnv,\n    mod::ExaAdmm.AbstractOPFModel\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_increment_outer-Tuple{ExaAdmm.AdmmEnv, ExaAdmm.AbstractOPFModel}","page":"Development Guide","title":"ExaAdmm.admm_increment_outer","text":"Increment outer iteration counter by one.\n\n\n\n\n\n","category":"method"},{"location":"dev/#ExaAdmm.admm_increment_reset_inner-Tuple{ExaAdmm.AdmmEnv, ExaAdmm.AbstractOPFModel}","page":"Development Guide","title":"ExaAdmm.admm_increment_reset_inner","text":"Reset inner iteration counter to zero.\n\n\n\n\n\n","category":"method"},{"location":"dev/#ExaAdmm.admm_increment_inner-Tuple{ExaAdmm.AdmmEnv, ExaAdmm.AbstractOPFModel}","page":"Development Guide","title":"ExaAdmm.admm_increment_inner","text":"Increment inner iteration counter by one.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Functions-in-myopf_admm_prepoststep_{cpu,gpu}.jl","page":"Development Guide","title":"Functions in myopf_admm_prepoststep_{cpu,gpu}.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_outer_prestep(\n   env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n   mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)\nExaAdmm.admm_inner_prestep(\n   env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n   mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)\nExaAdmm.admm_poststep(\n   env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n   mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_outer_prestep-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_outer_prestep","text":"Implement any algorithmic steps required before each outer iteration.\n\n\n\n\n\n","category":"method"},{"location":"dev/#ExaAdmm.admm_inner_prestep-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_inner_prestep","text":"Implement any algorithmic steps required before each inner iteration.\n\n\n\n\n\n","category":"method"},{"location":"dev/#ExaAdmm.admm_poststep-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_poststep","text":"Implement any steps required after the algorithm terminates.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Functions-in-myopf_admm_update_x_{cpu,gpu}.jl","page":"Development Guide","title":"Functions in myopf_admm_update_x_{cpu,gpu}.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_update_x(\n    env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n    mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_update_x-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_update_x","text":"Update variable x, representing the variables for generators and lines in the component-based decomposition of ACOPF.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Functions-in-myopf_admm_update_xbar_{cpu,gpu}.jl","page":"Development Guide","title":"Functions in myopf_admm_update_xbar_{cpu,gpu}.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_update_xbar(\n    env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n    mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_update_xbar-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_update_xbar","text":"Update variable xbar, representing the variables for buses in the component-based decomposition of ACOPF.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Functions-in-myopf_admm_update_z_{cpu,gpu}.jl","page":"Development Guide","title":"Functions in myopf_admm_update_z_{cpu,gpu}.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_update_z(\n    env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n    mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_update_z-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_update_z","text":"Update variable z, representing the artificial variables that are driven to zero in the two-level ADMM.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Functions-in-myopf_admm_update_l_{cpu,gpu}.jl","page":"Development Guide","title":"Functions in myopf_admm_update_l_{cpu,gpu}.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_update_l(\n    env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n    mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_update_l-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_update_l","text":"Update multipliers λ for consensus constraints, x - xbar + z = 0.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Functions-in-myopf_admm_update_lz_{cpu,gpu}.jl","page":"Development Guide","title":"Functions in myopf_admm_update_lz_{cpu,gpu}.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_update_lz(\n    env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n    mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_update_lz-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_update_lz","text":"Compute and update multipliers λ_z for the augmented Lagrangian wit respect to z=0 constraint.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Functions-in-myopf_admm_update_residual_{cpu,gpu}.jl","page":"Development Guide","title":"Functions in myopf_admm_update_residual_{cpu,gpu}.jl","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"ExaAdmm.admm_update_residual(\n    env::ExaAdmm.AdmmEnv{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}},\n    mod::ExaAdmm.AbstractOPFModel{Float64,Array{Float64,1},Array{Int,1},Array{Float64,2}}\n)","category":"page"},{"location":"dev/#ExaAdmm.admm_update_residual-Tuple{ExaAdmm.AdmmEnv{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}, ExaAdmm.AbstractOPFModel{Float64, Vector{Float64}, Vector{Int64}, Matrix{Float64}}}","page":"Development Guide","title":"ExaAdmm.admm_update_residual","text":"Compute and update the primal and dual residuals at current iteration.\n\nArguments\n\nenv::AdmmEnv – struct that defines the environment of ADMM\nmod::ModelAcopf – struct that defines model\n\nNotes\n\nThe primal and dual residuals are stored in mod.solution.rp and mod.solution.rd, respectively.\n\n\n\n\n\n","category":"method"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"note: Note\nInternally, these x and xbar correspond to u and v variables in the code, respectively. Variables u and v have the same structure. For example in ACOPF, the variable stores modeling variable values in the following order:(colorblue (p_gi q_gi)_i=1dotsG colorred (p_ijell q_ijell p_jiell q_jiell w_iell w_jell t_iell t_jell)_ell=1dotsL)","category":"page"},{"location":"dev/#Notes-for-GPU","page":"Development Guide","title":"Notes for GPU","text":"","category":"section"},{"location":"dev/","page":"Development Guide","title":"Development Guide","text":"To make your model run on Nvidia GPUs, the AdmmEnv and you also need to implement these functions that take arrays of type CuArray. You can find examples in interface/solve_acopf.jl and interface/solve_mpacopf.jl.","category":"page"},{"location":"#ExaAdmm.jl","page":"Home","title":"ExaAdmm.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExaAdmm.jl is a Julia package that implements the two-level alternating direction method of multipliers (ADMM) for the decomposition of alternating current optimal power flow (ACOPF) on GPUs. In particular, the package implements the component-based decomposition of","category":"page"},{"location":"","page":"Home","title":"Home","text":"single-period ACOPF\nmulti-period ACOPF","category":"page"},{"location":"","page":"Home","title":"Home","text":"and also provides the interface to solve multi-period ACOPF in a rolling horizon fashion.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed in the Julia REPL with the command below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] ExaAdmm","category":"page"},{"location":"","page":"Home","title":"Home","text":"Running the algorithms on GPU requires Nvidia GPUs with CUDA.jl. ","category":"page"},{"location":"#How-to-run","page":"Home","title":"How to run","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, ExaAdmm.jl supports electrical grid files in the MATLAB format. You can download them from here. Below shows an example of solving case1354pegase.m using ExaAdmm.jl on GPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"env, mod = ExaAdmm.solve_acopf(\n    \"case1354pegase.m\"; \n    rho_pq=1e1, \n    rho_va=1e3, \n    outer_iterlim=20, \n    inner_iterlim=20, \n    scale=1e-4, \n    tight_factor=0.99, \n    use_gpu=true\n);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following table shows parameter values we used for solving pegase and ACTIVSg data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Data rho_pq rho_va scale obj_scale\n1354pegase 1e1 1e3 1e-4 1.0\n2869pegase 1e1 1e3 1e-4 1.0\n9241pegase 5e1 5e3 1e-4 1.0\n13659pegase 5e1 5e3 1e-4 1.0\nACTIVSg25k 3e3 3e4 1e-5 1.0\nACTIVSg70k 3e4 3e5 1e-5 2.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have used the same tight_factor=0.99, outer_iterlim=20, and inner_iterlim=1000 for all of the above data.","category":"page"},{"location":"#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Youngdae Kim and Kibaek Kim. \"Accelerated Computation and Tracking of AC Optimal Power Flow Solutions using GPUs\" arXiv preprint arXiv:2110.06879, 2021\nYoungdae Kim, François Pacaud, Kibaek Kim, and Mihai Anitescu. \"Leveraging GPU batching for scalable nonlinear programming through massive lagrangian decomposition\" arXiv preprint arXiv:2106.14995, 2021","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This research was supported by the Exascale ComputingProject (17-SC-20-SC),  a collaborative effort of the U.S. Department of Energy Office of Science and the National Nuclear Security Administration. This material is based upon work supported by the U.S. Department of Energy, Office of Science, under contract number DE-AC02-06CH11357.","category":"page"}]
}
